/*
using BMDCameraMVVM.Core.Models;
using BMDCore.Config;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading.Tasks;
*/

namespace BMDCore.CCU
{
    /// <summary>
    /// BMD: CCUDecodingFunctions.swift
    /// </summary>
    public static class CCUDecodingFunctions
    {
        // For Testing Purposes
        public static string DecodeCCUPacketForDisplay(byte[] byteArray)
        {
            bool isValid = CCUValidationFunctions.ValidateCCUPacket(byteArray);

            if (isValid)
            {
                byte commandLength = byteArray[CCUPacketTypes.PacketFormatIndex.CommandLength];
                CCUPacketTypes.Category category = (CCUPacketTypes.Category)byteArray[CCUPacketTypes.PacketFormatIndex.Category];
                byte parameter = byteArray[CCUPacketTypes.PacketFormatIndex.Parameter];

                string categoryName = "";
                string parameterName = "";

                switch (category)
                {
                    case CCUPacketTypes.Category.Lens:
                        categoryName = "Lens";
                        // DecodeLensCategory(parameter: parameter, payloadData: payloadData, respondTo: packetDecodedDelegate);
                        if (Enum.IsDefined(typeof(CCUPacketTypes.LensParameter), parameter))
                        {
                            CCUPacketTypes.LensParameter parameterType = (CCUPacketTypes.LensParameter)parameter;

                            switch (parameterType)
                            {
                                case CCUPacketTypes.LensParameter.ApertureFstop:
                                    parameterName = "Aperture fStop";
                                    break;
                                case CCUPacketTypes.LensParameter.ApertureNormalised:
                                    parameterName = "Aperture Normalised";
                                    break;
                                case CCUPacketTypes.LensParameter.ApertureOrdinal:
                                    parameterName = "Aperture Ordinal";
                                    break;
                                case CCUPacketTypes.LensParameter.AutoAperture:
                                    parameterName = "Auto Aperture";
                                    break;
                                case CCUPacketTypes.LensParameter.AutoFocus:
                                    parameterName = "Auto Focus";
                                    break;
                                case CCUPacketTypes.LensParameter.ContinuousZoom:
                                    parameterName = "Continuous Zoom";
                                    break;
                                case CCUPacketTypes.LensParameter.Focus:
                                    parameterName = "Focus";
                                    break;
                                case CCUPacketTypes.LensParameter.ImageStabilisation:
                                    parameterName = "Image Stabilisation";
                                    break;
                                case CCUPacketTypes.LensParameter.Zoom:
                                    parameterName = "Zoom";
                                    break;
                                case CCUPacketTypes.LensParameter.ZoomNormalised:
                                    parameterName = "Zoom Normalised";
                                    break;
                                default:
                                    parameterName = "Not Defined";
                                    break;
                            }
                        }
                        else
                            parameterName = "Unknown";

                        break;
                    case CCUPacketTypes.Category.Video:
                        categoryName = "Video";

                        if (Enum.IsDefined(typeof(CCUPacketTypes.VideoParameter), parameter))
                        {
                            CCUPacketTypes.VideoParameter parameterType = (CCUPacketTypes.VideoParameter)parameter;

                            switch (parameterType)
                            {
                                case CCUPacketTypes.VideoParameter.SensorGain:
                                    parameterName = "Sensor Gain";
                                    break;
                                case CCUPacketTypes.VideoParameter.ManualWB:
                                    parameterName = "Manual WB";
                                    break;
                                case CCUPacketTypes.VideoParameter.Exposure:
                                    parameterName = "Exposure";
                                    break;
                                case CCUPacketTypes.VideoParameter.RecordingFormat:
                                    parameterName = "Recording Format";
                                    break;
                                case CCUPacketTypes.VideoParameter.AutoExposureMode:
                                    parameterName = "Auto Exposure Mode";
                                    break;
                                case CCUPacketTypes.VideoParameter.ShutterAngle:
                                    parameterName = "Shutter Angle";
                                    break;
                                case CCUPacketTypes.VideoParameter.ShutterSpeed:
                                    parameterName = "Shutter Speed";
                                    break;
                                case CCUPacketTypes.VideoParameter.Gain:
                                    parameterName = "Gain";
                                    break;
                                case CCUPacketTypes.VideoParameter.ISO:
                                    parameterName = "ISO";
                                    break;
                                case CCUPacketTypes.VideoParameter.DisplayLUT:
                                    parameterName = "Display LUT";
                                    break;
                                default:
                                    parameterName = "Not Defined";
                                    break;
                            }
                        }
                        else
                            parameterName = "Unknown";

                        break;
                    case CCUPacketTypes.Category.Status:
                        categoryName = "Status";

                        if (Enum.IsDefined(typeof(CCUPacketTypes.StatusParameter), parameter))
                        {
                            CCUPacketTypes.StatusParameter parameterType = (CCUPacketTypes.StatusParameter)parameter;

                            switch (parameterType)
                            {
                                case CCUPacketTypes.StatusParameter.Battery:
                                    parameterName = "Battery";
                                    break;
                                case CCUPacketTypes.StatusParameter.CameraSpec:
                                    parameterName = "Camera Spec (not catered for)";
                                    break;
                                case CCUPacketTypes.StatusParameter.DisplayParameters:
                                    parameterName = "Display Parameters (not catered for)";
                                    break;
                                case CCUPacketTypes.StatusParameter.DisplayThresholds:
                                    parameterName = "Display Thresholds (not catered for)";
                                    break;
                                case CCUPacketTypes.StatusParameter.DisplayTimecode:
                                    parameterName = "Display Timecode (not catered for)";
                                    break;
                                case CCUPacketTypes.StatusParameter.MediaStatus:
                                    parameterName = "Media Status";
                                    break;
                                case CCUPacketTypes.StatusParameter.RemainingRecordTime:
                                    parameterName = "Remaining Record Time";
                                    break;
                                case CCUPacketTypes.StatusParameter.SwitcherStatus:
                                    parameterName = "Switcher Status (not catered for)";
                                    break;
                                default:
                                    parameterName = "Not Defined";
                                    break;
                            }
                        }
                        else
                            parameterName = "Unknown";

                        break;
                    case CCUPacketTypes.Category.Media:
                        categoryName = "Media";

                        if (Enum.IsDefined(typeof(CCUPacketTypes.MediaParameter), parameter))
                        {
                            CCUPacketTypes.MediaParameter parameterType = (CCUPacketTypes.MediaParameter)parameter;

                            switch (parameterType)
                            {
                                case CCUPacketTypes.MediaParameter.Codec:
                                    parameterName = "Codec";
                                    break;
                                case CCUPacketTypes.MediaParameter.TransportMode:
                                    parameterName = "Transport Mode";
                                    break;
                                default:
                                    parameterName = "Not Defined";
                                    break;
                            }
                        }
                        else
                            parameterName = "Unknown";

                        break;
                    case CCUPacketTypes.Category.Metadata:
                        categoryName = "Metadata";

                        if (Enum.IsDefined(typeof(CCUPacketTypes.MetadataParameter), parameter))
                        {
                            CCUPacketTypes.MetadataParameter parameterType = (CCUPacketTypes.MetadataParameter)parameter;

                            switch (parameterType)
                            {
                                case CCUPacketTypes.MetadataParameter.Reel:
                                    parameterName = "Reel";
                                    break;
                                case CCUPacketTypes.MetadataParameter.SceneTags:
                                    parameterName = "Scene Tag";
                                    break;
                                case CCUPacketTypes.MetadataParameter.Scene:
                                    parameterName = "Scene";
                                    break;
                                case CCUPacketTypes.MetadataParameter.Take:
                                    parameterName = "Take";
                                    break;
                                case CCUPacketTypes.MetadataParameter.GoodTake:
                                    parameterName = "Good Take";
                                    break;
                                case CCUPacketTypes.MetadataParameter.SlateForType:
                                    parameterName = "Slate for Type";
                                    break;
                                case CCUPacketTypes.MetadataParameter.SlateForName:
                                    parameterName = "Slate for Name";
                                    break;
                                default:
                                    parameterName = "Not Defined";
                                    break;
                            }
                        }
                        else
                            parameterName = "Unknown";

                        break;

                    default:
                        categoryName = "Unknown";
                        break;
                }

                return categoryName + ": " + parameterName;
            }
            return "Invalid Packet: " + byteArray;
        }

        public static void DecodeCCUPacket(byte[] byteArray, ref ObservableBMDCamera observableBMDCamera)
        {
            bool isValid = CCUValidationFunctions.ValidateCCUPacket(byteArray);

            if(isValid)
            {
                byte commandLength = byteArray[CCUPacketTypes.PacketFormatIndex.CommandLength];
                CCUPacketTypes.Category category = (CCUPacketTypes.Category)byteArray[CCUPacketTypes.PacketFormatIndex.Category];
                byte parameter = byteArray[CCUPacketTypes.PacketFormatIndex.Parameter];

                byte dataLength = (byte)(commandLength - CCUPacketTypes.kCCUCommandHeaderSize);
                byte payloadOffset = CCUPacketTypes.kCUUPayloadOffset;
                byte[] payloadData = new byte[dataLength];
                Array.Copy(byteArray, payloadOffset, payloadData, 0, dataLength);

                try
                {
                    DecodePayloadData(category, parameter, payloadData, ref observableBMDCamera);
                }
                catch(Exception ex)
                {
                    throw ex;
                }
            }
        }

        static void DecodePayloadData(CCUPacketTypes.Category category, byte parameter, byte[] payloadData, ref ObservableBMDCamera observableBMDCamera)
        {
            switch(category)
            {
                case CCUPacketTypes.Category.Lens:
                    DecodeLensCategory(parameter, payloadData, ref observableBMDCamera);
                    break;
                case CCUPacketTypes.Category.Video:
                    DecodeVideoCategory(parameter, payloadData, ref observableBMDCamera);
                    break;
                case CCUPacketTypes.Category.Status:
                    DecodeStatusCategory(parameter, payloadData, ref observableBMDCamera);
                    break;
                case CCUPacketTypes.Category.Media:
                    DecodeMediaCategory(parameter, payloadData, ref observableBMDCamera);
                    break;
                case CCUPacketTypes.Category.Metadata:
                    DecodeMetadataCategory(parameter, payloadData, ref observableBMDCamera);
                    break;
                default:
                    break;
            }
        }

        // See https://stackoverflow.com/a/40239850
        // Converts a byte array into an array of another type (e.g. byte array into int array using sets of 4 bytes to construct ints, so a 12 byte array returns an array of 3 ints)
        public static T[] ConvertPayloadData<T>(byte[] data)
        {
            var typeSize = System.Runtime.InteropServices.Marshal.SizeOf(typeof(T));
            var size = data.Count() / typeSize;
            var returnArray = new T[size];
            for (var index = 0; index < size; index++)
            {
                switch (Type.GetTypeCode(typeof(T)))
                {
                    case TypeCode.Int32:
                        returnArray[index] = (T)Convert.ChangeType(BitConverter.ToInt32(data, index * typeSize), typeof(T));
                        break;
                    case TypeCode.Int16:
                        returnArray[index] = (T)Convert.ChangeType(BitConverter.ToInt16(data, index * typeSize), typeof(T));
                        break;
                    case TypeCode.SByte:
                        // Note that we are converting the byte to sbyte withuot moving bits
                        returnArray[index] = (T)Convert.ChangeType(unchecked((sbyte)data[index]), typeof(T));
                        // returnArray[index] = (T)Convert.ChangeType(data[index], typeof(T));
                        break;
                    default:
                        throw new Exception("Type not catered for in ConvertPayloadDataWithExpectedCount");
                }
            }

            return returnArray;
        }

        public static T[] ConvertPayloadDataWithExpectedCount<T>(byte[] data, int expectedCount)
        {
            var typeSize = System.Runtime.InteropServices.Marshal.SizeOf(typeof(T));
            var size = data.Count() / typeSize;

            if(size != expectedCount)
                throw new Exception("Payload expected count (" + expectedCount + ") not equal to converted count (" + size + ")");

            var returnArray = new T[size];
            for (var index = 0; index < size; index++)
            {
                switch (Type.GetTypeCode(typeof(T)))
                {
                    case TypeCode.Int32:
                        returnArray[index] = (T)Convert.ChangeType(BitConverter.ToInt32(data, index * typeSize), typeof(T));
                        break;
                    case TypeCode.Int16:
                        returnArray[index] = (T)Convert.ChangeType(BitConverter.ToInt16(data, index * typeSize), typeof(T));
                        break;
                    case TypeCode.SByte:
                        // Note that we are converting the byte to sbyte withuot moving bits
                        returnArray[index] = (T)Convert.ChangeType(unchecked((sbyte)data[index]), typeof(T));
                        break;
                    case TypeCode.Byte:
                        returnArray[index] = (T)Convert.ChangeType(data[index], typeof(T));
                        break;
                    default:
                        throw new Exception("Type not catered for in ConvertPayloadDataWithExpectedCount");
                }
            }

            return returnArray;
        }

        static string ConvertPayloadDataToString(byte[] data)
        {
            return Encoding.UTF8.GetString(data);
        }

        #region Category Lens

        // Lens Category decoding functions
        static void DecodeLensCategory(byte parameter, byte[] payloadData, ref ObservableBMDCamera observableBMDCamera)
        {
            if (Enum.IsDefined(typeof(CCUPacketTypes.LensParameter), parameter))
            {
                CCUPacketTypes.LensParameter parameterType = (CCUPacketTypes.LensParameter)parameter;

                switch (parameterType)
                {
                    case CCUPacketTypes.LensParameter.ApertureFstop:
                        DecodeApertureFStop(payloadData, ref observableBMDCamera);
                        break;
                    case CCUPacketTypes.LensParameter.ApertureNormalised:
                        DecodeApertureNormalised(payloadData, ref observableBMDCamera);
                        break;
                    case CCUPacketTypes.LensParameter.ApertureOrdinal:
                        // Not catered for
                        break;
                    case CCUPacketTypes.LensParameter.AutoAperture:
                        // Not catered for
                        break;
                    case CCUPacketTypes.LensParameter.AutoFocus:
                        // Not catered for
                        break;
                    case CCUPacketTypes.LensParameter.ContinuousZoom:
                        // Not catered for
                        break;
                    case CCUPacketTypes.LensParameter.Focus:
                        // Not catered for
                        break;
                    case CCUPacketTypes.LensParameter.ImageStabilisation:
                        // Not catered for
                        break;
                    case CCUPacketTypes.LensParameter.Zoom:
                        // Not catered for
                        break;
                    case CCUPacketTypes.LensParameter.ZoomNormalised:
                        // Not catered for
                        break;
                    default:
                        break;
                }
            }
            else
                throw new Exception("Invalid value for LensParameter: " + parameter + ".");
        }

        static void DecodeApertureFStop(byte[] inData, ref ObservableBMDCamera observableBMDCamera)
        {
            // TEMP Test
            float Exponent = (1 << 11);
            float myfStop = 16f;
            float result = myfStop * Exponent;


            // short[] data = ConvertPayloadDataWithExpectedCount<short>(inData, 1);
            short[] data = ConvertPayloadDataWithExpectedCount<short>(inData, 2); // We're receiving 4 bytes, though expecting 2 bytes (equivalent to a Short / Int16), so this avoids an exception, though it's not clear why it's 4 bytes
            short apertureNumber = data[0];

            short fStopIndex = -1;
            if(apertureNumber != CCUPacketTypes.kLensAperture_NoLens) {
                fStopIndex = LensConfig.GetIndexForApertureNumber(apertureNumber);
            }

            observableBMDCamera.onIrisReceived(apertureNumber, fStopIndex);
        }

        // MS
        static void DecodeApertureNormalised(byte[] inData, ref ObservableBMDCamera observableBMDCamera)
        {
            short[] data = ConvertPayloadDataWithExpectedCount<short>(inData, 1); // Receiving a fixed16 number, as a short it will be 0-2,048 representing 0.0-1.0
            short apertureNormalisedNumber = data[0];

            observableBMDCamera.onNormalisedApertureReceived(apertureNormalisedNumber);
        }

        #endregion

        #region Category Video

        // Video Category decoding functions
        static void DecodeVideoCategory(byte parameter, byte[] payloadData, ref ObservableBMDCamera observableBMDCamera)
        {
            if (Enum.IsDefined(typeof(CCUPacketTypes.VideoParameter), parameter))
            {
                CCUPacketTypes.VideoParameter parameterType = (CCUPacketTypes.VideoParameter)parameter;

                switch (parameterType)
                {
                    case CCUPacketTypes.VideoParameter.SensorGain:
                        DecodeSensorGain(payloadData);
                        break;
                    case CCUPacketTypes.VideoParameter.ManualWB:
                        DecodeManualWB(payloadData, ref observableBMDCamera);
                        break;
                    case CCUPacketTypes.VideoParameter.Exposure:
                        DecodeExposure(payloadData);
                        break;
                    case CCUPacketTypes.VideoParameter.RecordingFormat:
                        DecodeRecordingFormat(payloadData, ref observableBMDCamera);
                        break;
                    case CCUPacketTypes.VideoParameter.AutoExposureMode:
                        DecodeAutoExposureMode(payloadData);
                        break;
                    case CCUPacketTypes.VideoParameter.ShutterAngle:
                        DecodeShutterAngle(payloadData, ref observableBMDCamera);
                        break;
                    case CCUPacketTypes.VideoParameter.ShutterSpeed:
                        DecodeShutterSpeed(payloadData, ref observableBMDCamera);
                        break;
                    case CCUPacketTypes.VideoParameter.Gain:
                        DecodeGain(payloadData);
                        break;
                    case CCUPacketTypes.VideoParameter.ISO:
                        DecodeISO(payloadData, ref observableBMDCamera);
                        break;
                    case CCUPacketTypes.VideoParameter.DisplayLUT:
                        DecodeDisplayLUT(payloadData);
                        break;
                    default:
                        break;
                }
            }
            else
                throw new Exception("Invalid value for VideoParameter: " + parameter + ".");
        }

        static void DecodeSensorGain(byte[] inData)
        {
            byte[] data = ConvertPayloadDataWithExpectedCount<byte>(inData, 1);
            int sensorGainValue = data[0];
            int sensorGain = sensorGainValue * (int)(VideoConfig.kReceivedSensorGainBase);
        
            // packetDecodedDelegate.onISOReceived(sensorGain)
        }

        static void DecodeManualWB(byte[] inData, ref ObservableBMDCamera observableBMDCamera)
        {
            short[] data = ConvertPayloadDataWithExpectedCount<short>(inData, 2);

            short whiteBalance = data[0];
            short tint = data[1];

            observableBMDCamera.onWhiteBalanceReceived(whiteBalance, tint);
            // packetDecodedDelegate.onWhiteBalanceReceived(whiteBalance, tint)
        }

        static void DecodeExposure(byte[] inData)
        {
            Int32[] data = ConvertPayloadDataWithExpectedCount<Int32>(inData, 1);
            Int32 shutterSpeed = data[0];
            
            //packetDecodedDelegate.onExposureReceived(shutterSpeed)
        }

        static void DecodeRecordingFormat(byte[] inData, ref ObservableBMDCamera observableBMDCamera)
        {
            short[] data = ConvertPayloadDataWithExpectedCount<short>(inData, 5);

            CCUPacketTypes.RecordingFormatData recordingFormatData = new CCUPacketTypes.RecordingFormatData();
            recordingFormatData.frameRate = data[0];
            recordingFormatData.offSpeedFrameRate = data[1];
            recordingFormatData.width = data[2];
            recordingFormatData.height = data[3];

            ushort flags = (ushort)data[4];
            recordingFormatData.mRateEnabled = (ushort)(((int)flags & (int)CCUPacketTypes.VideoRecordingFormat.FileMRate)) > 0;
            recordingFormatData.offSpeedEnabled = (ushort)(((int)flags & (int)CCUPacketTypes.VideoRecordingFormat.SensorOffSpeed)) > 0;
            recordingFormatData.interlacedEnabled = (ushort)(((int)flags & (int)CCUPacketTypes.VideoRecordingFormat.Interlaced)) > 0;
            recordingFormatData.windowedModeEnabled = (ushort)(((int)flags & (int)CCUPacketTypes.VideoRecordingFormat.WindowedMode)) > 0;

            observableBMDCamera.onRecordingFormatReceived(recordingFormatData);
            // packetDecodedDelegate.onRecordingFormatReceived(recordingFormatData)
        }

        static void DecodeAutoExposureMode(byte[] inData)
        {
            byte[] data = ConvertPayloadDataWithExpectedCount<byte>(inData, 1);
            CCUPacketTypes.AutoExposureMode autoExposureMode = (CCUPacketTypes.AutoExposureMode)inData[0];

            // packetDecodedDelegate.onAutoExposureModeReceived(autoExposureMode)
        }

        static void DecodeShutterAngle(byte[] inData, ref ObservableBMDCamera observableBMDCamera)
        {
            Int32[] data = ConvertPayloadDataWithExpectedCount<Int32>(inData, 1);
            Int32 shutterAngleX100 = data[0];

            observableBMDCamera.onShutterAngleReceived(shutterAngleX100);
            // packetDecodedDelegate.onShutterAngleReceived(shutterAngleX100)
        }

        static void DecodeShutterSpeed(byte[] inData, ref ObservableBMDCamera observableBMDCamera)
        {
            Int32[] data = ConvertPayloadDataWithExpectedCount<Int32>(inData, 1);
            Int32 shutterSpeed = data[0]; // Result is the denominator in 1/X, e.g. shutterSpeed = 24 is a shutter speed of 1/24

            observableBMDCamera.onShutterSpeedReceived(shutterSpeed);
            // packetDecodedDelegate.onShutterSpeedReceived(shutterSpeed)
        }

        static void DecodeGain(byte[] inData)
        {
            byte[] data = ConvertPayloadDataWithExpectedCount<byte>(inData, 1);
            byte gain = data[0];

            // packetDecodedDelegate.onGainReceived(Int(gain))
	    }

        static void DecodeISO(byte[] inData, ref ObservableBMDCamera observableBMDCamera)
        {
            Int32[] data = ConvertPayloadDataWithExpectedCount<Int32>(inData, 1);
            Int32 iso = data[0];

            observableBMDCamera.onISOReceived(iso);
            // packetDecodedDelegate.onISOReceived(Int(iso))
        }

        static void DecodeDisplayLUT(byte[] inData)
        {
            byte[] data = ConvertPayloadDataWithExpectedCount<byte>(inData, 2);

            CCUPacketTypes.SelectedLUT selectedLUT = (CCUPacketTypes.SelectedLUT)data[0];
            bool enabled = data[1] == 1;

            // packetDecodedDelegate.onDisplayLUTReceived(selectedLUT, enabled) // NEW
        }

        #endregion

        #region Category Status

        // Category: Status
        // Status Category decoding functions
        static void DecodeStatusCategory(byte parameter, byte[] payloadData, ref ObservableBMDCamera observableBMDCamera) {
            if (Enum.IsDefined(typeof(CCUPacketTypes.StatusParameter), parameter))
            {
                CCUPacketTypes.StatusParameter parameterType = (CCUPacketTypes.StatusParameter)parameter;

                switch (parameterType)
                {
                    case CCUPacketTypes.StatusParameter.Battery:
                        // Not catered for
                        // Attempting to cater for it
                        DecodeBattery(payloadData, ref observableBMDCamera);
                        break;
                    case CCUPacketTypes.StatusParameter.CameraSpec:
                        // Not catered for
                        break;
                    case CCUPacketTypes.StatusParameter.DisplayParameters:
                        // Not catered for
                        break;
                    case CCUPacketTypes.StatusParameter.DisplayThresholds:
                        // Not catered for
                        break;
                    case CCUPacketTypes.StatusParameter.DisplayTimecode:
                        // Not catered for
                        break;
                    case CCUPacketTypes.StatusParameter.MediaStatus:
                        DecodeMediaStatus(payloadData);
                        break;
                    case CCUPacketTypes.StatusParameter.RemainingRecordTime:
                        DecodeRemainingRecordTime(payloadData, ref observableBMDCamera);
                        break;
                    case CCUPacketTypes.StatusParameter.SwitcherStatus:
                        // Not catered for
                        break;
                    default:
                        break;
                    }
            }
            else
                throw new Exception("Invalid value for StatusParameter: " + parameter + ".");
        }

        // MS
        static void DecodeBattery(byte[] inData, ref ObservableBMDCamera observableBMDCamera)
        {
            short[] data = ConvertPayloadDataWithExpectedCount<short>(inData, 3);

            CCUPacketTypes.BatteryStatusData batteryStatusData = new CCUPacketTypes.BatteryStatusData();

            batteryStatusData.batteryLevelX1000 = data[0];

            // Not sure what data[1] is - value is typically 100

            ushort flags = (ushort)data[2];

            batteryStatusData.batteryPresent = (ushort)(((int)flags & (int)CCUPacketTypes.BatteryStatus.BatteryPresent)) > 0;
            batteryStatusData.ACPresent = (ushort)(((int)flags & (int)CCUPacketTypes.BatteryStatus.ACPresent)) > 0;
            batteryStatusData.batteryIsCharging = (ushort)(((int)flags & (int)CCUPacketTypes.BatteryStatus.BatteryIsCharging)) > 0;
            batteryStatusData.chargeRemainingPercentageIsEstimated = (ushort)(((int)flags & (int)CCUPacketTypes.BatteryStatus.ChargeRemainingPercentageIsEstimated)) > 0;
            batteryStatusData.preferVoltageDisplay = (ushort)(((int)flags & (int)CCUPacketTypes.BatteryStatus.PreferVoltageDisplay)) > 0;

            observableBMDCamera.onBatteryStatusReceived(batteryStatusData);
        }

        static void DecodeMediaStatus(byte[] inData)
        {
            sbyte[] data = ConvertPayloadData<sbyte>(inData);
            int slotCount = Math.Min(data.Count(), 2);

            CCUPacketTypes.MediaStatus[] mediaStatuses = new CCUPacketTypes.MediaStatus[2] { CCUPacketTypes.MediaStatus.None, CCUPacketTypes.MediaStatus.None };

            for(int slotIndex = 0; slotIndex < slotCount; slotIndex++)
            {
                if (Enum.IsDefined(typeof(CCUPacketTypes.MediaStatus), data[slotIndex]))
                    mediaStatuses[slotIndex] = (CCUPacketTypes.MediaStatus)data[slotIndex];
            }

            // packetDecodedDelegate.onMediaStatusReceived(mediaStatuses)
        }

        static void DecodeRemainingRecordTime(byte[] inData, ref ObservableBMDCamera observableBMDCamera)
        {
            short[] data = ConvertPayloadData<short>(inData);

            string noCardString = Resources.Localizable.Transport_NoCard;
            string[] remainingTimesStrings = new string[2] { noCardString, noCardString };
            short[] remainingTimesInMinutes = new short[2] { 0, 0 };
            int slotCount = Math.Min(data.Count(), 2);
            for(int slotIndex = 0; slotIndex < slotCount; slotIndex++)
            {
                short remainingTimeValue = data[slotIndex];
                if (remainingTimeValue > 0)
                {
                    if(remainingTimeValue >= 60)
                    {
                        string min = Resources.Localizable.Transport_Min;
                        remainingTimesInMinutes[slotIndex] = (short)(remainingTimeValue / 60);
                        remainingTimesStrings[slotIndex] = remainingTimesInMinutes[slotIndex] + "min";
                    }
                    else
                    {
                        string min = Resources.Localizable.Transport_Sec;
                        remainingTimesStrings[slotIndex] = remainingTimeValue + "sec";
                        remainingTimesInMinutes[slotIndex] = (short)(remainingTimeValue / 60);
                    }
                }
                else if (remainingTimeValue < 0)
                {
                    string min = Resources.Localizable.Transport_Min;
                    remainingTimesStrings[slotIndex] = -remainingTimeValue + "min";
                    remainingTimesInMinutes[slotIndex] = (short)-remainingTimeValue;
                }
                else
                    remainingTimesStrings[slotIndex] = Resources.Localizable.Transport_Full;
            }

            observableBMDCamera.onRecordTimeRemainingReceived(remainingTimesStrings, remainingTimesInMinutes);
            // packetDecodedDelegate.onRecordTimeRemainingReceived(remainingTimesStrings, remaingTimesInMinutes)
        }

        #endregion

        #region Category Media

        static void DecodeMediaCategory(byte parameter, byte[] payloadData, ref ObservableBMDCamera observableBMDCamera)
        {
            if (Enum.IsDefined(typeof(CCUPacketTypes.MediaParameter), parameter))
            {
                CCUPacketTypes.MediaParameter parameterType = (CCUPacketTypes.MediaParameter)parameter;

                switch(parameterType)
                {
                    case CCUPacketTypes.MediaParameter.Codec:
                        DecodeCodec(payloadData);
                        break;
                    case CCUPacketTypes.MediaParameter.TransportMode:
                        DecodeTransportMode(payloadData, observableBMDCamera);
                        break;
                    default:
                        break;
                }
            }
            else
                throw new Exception("Invalid value for MediaParameter: " + parameter + ".");
        }

        static void DecodeCodec(byte[] inData)
        {
            Camera.CodecInfo codecInfo = new Camera.CodecInfo { basicCodec = (CCUPacketTypes.BasicCodec)inData[0], codecVariant = inData[1] };

            // packetDecodedDelegate.onCodecReceived(mediaStatuses) // NEW
        }

        static void DecodeTransportMode(byte[] inData, ObservableBMDCamera observableBMDCamera)
        {
            sbyte[] data = ConvertPayloadDataWithExpectedCount<sbyte>(inData, 5);

            CCUPacketTypes.MediaTransportMode mode = (CCUPacketTypes.MediaTransportMode)unchecked((byte)data[0]);
            CCUPacketTypes.ActiveStorageMedium storageMediumDisk1 = (CCUPacketTypes.ActiveStorageMedium)unchecked((byte)data[3]);
            CCUPacketTypes.ActiveStorageMedium storageMediumDisk2 = (CCUPacketTypes.ActiveStorageMedium)unchecked((byte)data[4]);

            // if let mode = mode, let storageMediumDisk1 = storageMediumDisk1, let storageMediumDisk2 = storageMediumDisk2 {
            sbyte speed = data[1];
            byte flags = unchecked((byte)data[2]);

            bool loop = (byte)((int)flags & (int)CCUPacketTypes.MediaTransportFlag.Loop) > 0;
            bool playAll = (byte)((int)flags & (int)CCUPacketTypes.MediaTransportFlag.PlayAll) > 0;
            bool disk1Active = (byte)((int)flags & (int)CCUPacketTypes.MediaTransportFlag.Disk1Active) > 0;
            bool disk2Active = (byte)((int)flags & (int)CCUPacketTypes.MediaTransportFlag.Disk2Active) > 0;
            bool timelapseRecording = (byte)((int)flags & (int)CCUPacketTypes.MediaTransportFlag.TimelapseRecording) > 0;

            Camera.TransportInfo transportInfo = new Camera.TransportInfo();
            transportInfo.transportMode = mode;
            transportInfo.speed = speed;
            transportInfo.loop = loop;
            transportInfo.playAll = playAll;
            transportInfo.disk1Active = disk1Active;
            transportInfo.disk2Active = disk2Active;
            transportInfo.timelapseRecording = timelapseRecording;
            transportInfo.storageMediumDisk1 = storageMediumDisk1;
            transportInfo.storageMediumDisk2 = storageMediumDisk2;

            observableBMDCamera.onTransportInfoReceived(transportInfo);
            // packetDecodedDelegate.onTransportInfoReceived(transportInfo)

            // } else {
            // Logger.LogError("Decoding transport mode failed. mode = \(String(describing: mode))")
        }

        #endregion

        #region Category Metadata

        // BMD - Important: All metadata CCU commands are undocumented and are subject to change in a future release
        private static void DecodeMetadataCategory(byte parameter, byte[] payloadData, ref ObservableBMDCamera observableBMDCamera)
        {
            if (Enum.IsDefined(typeof(CCUPacketTypes.MetadataParameter), parameter))
            {
                CCUPacketTypes.MetadataParameter parameterType = (CCUPacketTypes.MetadataParameter)parameter;

                switch (parameterType)
                {
                    case CCUPacketTypes.MetadataParameter.Reel:
                        DecodeReel(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.SceneTags:
                        DecodeSceneTags(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.Scene:
                        DecodeScene(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.Take:
                        DecodeTake(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.GoodTake:
                        DecodeGoodTake(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.SlateForType:
                        DecodeSlateForType(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.SlateForName:
                        DecodeSlateForName(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.LensFocalLength:
                        string lensFocalLength = ConvertPayloadDataToString(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.LensDistance:
                        string lensDistance = ConvertPayloadDataToString(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.LensType:
                        string lensName = ConvertPayloadDataToString(payloadData);
                        break;
                    case CCUPacketTypes.MetadataParameter.LensIris:
                        DecodeLensIris(payloadData, observableBMDCamera);
                        break;
                    default:
                        break;
                }
            }
            else
                throw new Exception("Invalid value for MetadataParameter: " + parameter + ".");
        }

        static void DecodeReel(byte[] payloadData)
        {
            short[] data = ConvertPayloadDataWithExpectedCount<short>(payloadData, 1);
            short reelNumber = data[0];

            // packetDecodedDelegate.onReelReceived(reelNumber)
        }

        static void DecodeSceneTags(byte[] payloadData)
        {
            sbyte[] data = ConvertPayloadDataWithExpectedCount<sbyte>(payloadData, 3);

            if (Enum.IsDefined(typeof(CCUPacketTypes.MetadataSceneTag), data[0]) && Enum.IsDefined(typeof(CCUPacketTypes.MetadataLocationTypeTag), unchecked((byte)data[1])) && Enum.IsDefined(typeof(CCUPacketTypes.MetadataDayNightTag), unchecked((byte)data[2])))
            {
                CCUPacketTypes.MetadataSceneTag sceneTag = (CCUPacketTypes.MetadataSceneTag)data[0];
                CCUPacketTypes.MetadataLocationTypeTag locationType = (CCUPacketTypes.MetadataLocationTypeTag)unchecked((byte)data[1]);
                CCUPacketTypes.MetadataDayNightTag dayOrNight = (CCUPacketTypes.MetadataDayNightTag)unchecked((byte)data[2]);

                // packetDecodedDelegate.onSceneTagsReceived(sceneTag!, locationType!, dayOrNight!)
            }
            else
                throw new Exception("Failed enum cast: MetadataSceneTag (" + data[0] + "), MetadataLocationTypeTag (" + data[1] + "), MetadataDayNightTag (" + data[2] + ").");
        }

        static void DecodeScene(byte[] payloadData)
        {
            string sceneString = ConvertPayloadDataToString(payloadData);

            // packetDecodedDelegate.onSceneReceived(sceneString)
        }

        static void DecodeTake(byte[] payloadData)
        {
            sbyte[] data = ConvertPayloadDataWithExpectedCount<sbyte>(payloadData, 2);
            sbyte takeNumber = data[0];

            if (Enum.IsDefined(typeof(CCUPacketTypes.MetadataTakeTag), data[1]))
            {
                CCUPacketTypes.MetadataTakeTag takeTag = (CCUPacketTypes.MetadataTakeTag)data[1];
            }
            else
                throw new Exception("Failed enum cast: MetadataTakeTag (" + data[1] + ").");
        }

        static void DecodeGoodTake(byte[] payloadData)
        {
            sbyte[] data = ConvertPayloadDataWithExpectedCount<sbyte>(payloadData, 1);
            bool goodTake = data[0] == 1;

            // packetDecodedDelegate.onGoodTakeReceived(goodTake)
        }

        static void DecodeSlateForType(byte[] payloadData)
        {
            sbyte[] data = ConvertPayloadData<sbyte>(payloadData);
            if(data.Count() < 1) {
                throw new Exception("CCUDecodingError.PayloadConversionFailed");
            }

            if (Enum.IsDefined(typeof(CCUPacketTypes.MetadataSlateForType), data[0]))
            {
                CCUPacketTypes.MetadataSlateForType slateForType = (CCUPacketTypes.MetadataSlateForType)data[0];

                //packetDecodedDelegate.onSlateForTypeReceived(slateForType!)
            }
            else
                throw new Exception("CCUDecodingError.PayloadConversionFailed");
        }

        static void DecodeSlateForName(byte[] payloadData)
        {
            string slateForName = ConvertPayloadDataToString(payloadData);

            // packetDecodedDelegate.onSlateForNameReceived(slateForName)
        }

        // MS f/number as a string. "f5.9", "f2.8"
        static void DecodeLensIris(byte[] payloadData, ObservableBMDCamera observableBMDCamera)
        {
            string lensIris = ConvertPayloadDataToString(payloadData);

            observableBMDCamera.onLensIrisReceived(lensIris);
        }


        #endregion

        #region Timecode Decoding

        // Timecode decoding
        static char[] kTimecodeDigits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
        static int kTimecodeSize = System.Runtime.InteropServices.Marshal.SizeOf(typeof(UInt32));

        public static string TimecodeToString(UInt32 timecode) {
            string str = "";
            int digitCount = kTimecodeSize * 2;
            int shift = kTimecodeSize * 8 - 4;

            // Convert BCD timecode to string
            for (int i = 0; i < digitCount; i++)
            {
                int digit = ((int)(timecode) >> shift) & 0xF;

                if(digit < 10)
                    str += kTimecodeDigits[digit];
                else
                    str += "-";

                if((i % 2 == 1) && (i < digitCount - 1))
                    str += ":";

                shift -= 4;
            }

            return str;
        }

        // MS - Added in to trigger the change of value for the UI
        public static void DecodeTimecodePacket(UInt32 timecode, ref ObservableBMDCamera observableBMDCamera)
        {
            observableBMDCamera.onTimecodeReceived(TimecodeToString(timecode));
        }

        #endregion
    }
}